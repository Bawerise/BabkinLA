# Очистка и обслуживание данных в PostgreSQL

## 1. Зачем нужна очистка (VACUUM)

PostgreSQL использует **многоверсионность (MVCC)** — это означает, что при изменении данных создаются новые версии строк, а старые сохраняются, пока они могут понадобиться другим транзакциям.
Со временем эти старые версии становятся **мертвыми**, то есть больше ни одной транзакции не нужны. Однако они всё ещё занимают место на диске.

Если не удалять мёртвые версии строк:

* файлы таблиц и индексов будут **постоянно расти**;
* запросы начнут выполняться **медленнее**, так как системе придётся искать актуальные версии среди старых;
* может произойти **переполнение счётчика транзакций**, что приведёт к аварийной остановке сервера.

Чтобы этого не происходило, PostgreSQL регулярно выполняет процедуру **очистки (vacuum)** — удаляет устаревшие версии строк и освобождает внутреннее место в страницах таблиц.

---

## 2. Что делает процедура очистки

Очистка в PostgreSQL решает несколько задач:

1. **Удаляет мёртвые версии строк** — то есть физически очищает страницы таблиц от данных, которые больше не нужны.
2. **Очищает индексы** — удаляет записи, указывающие на мёртвые строки.
3. **Обновляет служебные карты:**

   * **Карту видимости (visibility map)** — помечает страницы, где все версии строк видны во всех снимках (они давно не изменялись).
   * **Карту свободного пространства (free space map)** — фиксирует, сколько свободного места есть в каждой странице.
4. **Собирает статистику** о данных для планировщика запросов (анализ).
5. **Проводит заморозку старых строк** — предотвращает переполнение счётчика транзакций.

Очистка — это не просто удаление «мусора», а важный элемент механизма поддержания производительности и корректности базы данных.

---

## 3. Карта видимости (Visibility Map)

Карта видимости хранится для каждой таблицы и показывает, **на каких страницах все версии строк видимы во всех снимках данных**.
Если страница отмечена в карте видимости:

* в ней **нет мёртвых строк**, и очистке можно не проверять её;
* она может использоваться для **индексного доступа без чтения таблицы** (если все нужные столбцы есть в индексе).

Таким образом, карта видимости помогает:

* ускорить работу процесса очистки;
* повысить производительность запросов, использующих только индексы.

Если карта видимости не обновляется, эффективность индексного доступа снижается.

---

## 4. Карта свободного пространства (Free Space Map)

Карта свободного пространства хранит информацию о **количестве свободного места** на каждой странице таблицы или индекса.
Она нужна, чтобы PostgreSQL мог быстро найти страницу, куда можно вставить новые данные.

Особенности:

* при добавлении строк свободное место уменьшается;
* после очистки — увеличивается;
* используется как при обычных вставках, так и при обновлениях строк.

Для индексов карта используется только для **пустых страниц**, полностью освобождённых от записей. Такие страницы могут быть позже возвращены в структуру индекса при необходимости.

---

## 5. Обновление статистики

Чтобы оптимизатор запросов строил эффективные планы, ему нужно знать:

* примерное количество строк в таблице;
* распределение значений по столбцам.

Эта информация называется **статистикой** и собирается с помощью **анализа (ANALYZE)**.

Анализ выполняет **случайную выборку** строк, чтобы не читать всю таблицу целиком.
Статистика не обязана быть абсолютно точной — достаточно, чтобы она **периодически обновлялась** и отражала актуальную структуру данных.
Если статистика устареет, оптимизатор начнёт строить неэффективные планы, и запросы могут выполняться значительно медленнее.

---

## 6. Заморозка строк

PostgreSQL использует **32-битный счётчик транзакций**. Это означает, что количество возможных номеров ограничено, и рано или поздно произойдёт **переполнение**.
Чтобы не нарушить порядок транзакций, сервер выполняет **заморозку** старых строк.

### Что делает заморозка:

* строки, созданные очень давно, получают специальный признак *frozen*;
* такие строки считаются существующими «вечно» и видны во всех снимках;
* при этом номер их транзакции можно переиспользовать.

Если не выполнять заморозку вовремя, сервер перестанет выделять новые номера транзакций и аварийно остановится.
Поэтому очистка (или автоочистка) должна регулярно выполнять заморозку.

---

## 7. Автоматическая очистка (Autovacuum)

В PostgreSQL очистка выполняется автоматически — через **механизм autovacuum**.

### Основные процессы:

* **Autovacuum launcher** — фоновый процесс, который следит за состоянием таблиц и запускает очистку, когда это необходимо.
* **Autovacuum workers** — рабочие процессы, выполняющие очистку конкретных таблиц.

Автоочистка:

* работает параллельно с другими транзакциями;
* обрабатывает только изменённые страницы (чтобы снизить нагрузку);
* динамически регулирует частоту запусков — чем активнее таблица обновляется, тем чаще она очищается.

> ⚠️ Отключать автоочистку нельзя.
> Без неё таблицы быстро разрастутся, а сервер может остановиться из-за переполнения счётчика транзакций.

Параметры автoочистки (частота, количество процессов и т.д.) можно гибко настраивать, но это подробно рассматривается в курсе DBA2.

---

## 8. Ручная очистка

Иногда администратор может запустить очистку вручную:

* `VACUUM` — только очистка;
* `ANALYZE` — только сбор статистики;
* `VACUUM ANALYZE` — и очистка, и анализ.

Также есть системная утилита `vacuumdb`, которая позволяет запускать эти команды из операционной системы.

> Ручная очистка полезна при крупных обновлениях или после массового удаления данных, но не должна заменять autovacuum.

---

## 9. Проблема разрастания таблиц и индексов

Очистка освобождает место внутри страниц, но **не уменьшает физический размер файлов** на уровне операционной системы.
Это значит, что освободившееся пространство остаётся внутри файла и будет использоваться под новые данные, но система не вернёт его обратно ОС.

Причины избыточного роста (bloat):

* слишком редкая очистка или отключённый autovacuum;
* массовые обновления или удаления данных;
* долгие транзакции, удерживающие старые версии строк.

### Последствия:

* перерасход места на диске;
* замедление последовательного чтения таблиц;
* снижение эффективности индексного доступа.

Чтобы устранить чрезмерное разрастание, можно выполнить **полную очистку или перестроение объектов**.

---

## 10. Полная очистка (VACUUM FULL)

`VACUUM FULL` полностью перестраивает таблицу и её индексы, физически перезаписывая их содержимое.
В результате:

* размер файлов уменьшается до минимума;
* освобождённое место возвращается операционной системе.

Однако у этой операции есть ограничения:

* таблица **полностью блокируется** на время выполнения;
* операция может занять значительное время.

`VACUUM FULL` стоит использовать только в исключительных случаях, когда таблица уже значительно разрослась.

---

## 11. Перестроение индексов

Индексы можно перестроить отдельно с помощью команды:

```sql
REINDEX;
```

Эта операция:

* создаёт новый индекс с тем же содержимым;
* блокирует запись в таблицу и использование перестраиваемого индекса;
* ускоряет работу запросов и уменьшает объём занимаемого места.

### Неблокирующее перестроение

Можно использовать:

```sql
REINDEX CONCURRENTLY;
```

Это перестраивает индекс **без блокировки таблицы**, но:

* занимает больше времени;
* не может выполняться внутри транзакции;
* не поддерживается для системных индексов и индексов с ограничениями `EXCLUDE`.

---

## 12. Краткие выводы

* PostgreSQL создаёт несколько версий строк — поэтому требуется регулярная очистка.
* Очистка удаляет устаревшие данные, обновляет служебные карты, собирает статистику и выполняет заморозку.
* Механизм **autovacuum** должен быть всегда включён.
* При чрезмерном росте файлов может понадобиться **полная очистка (VACUUM FULL)** или **перестроение индексов**.
* Правильная настройка очистки — основа стабильной и быстрой работы PostgreSQL.
