# Организация данных на низком уровне в PostgreSQL

## 1. Общие сведения

PostgreSQL хранит все данные базы в виде файлов на диске.
Каждый объект базы данных (таблица, индекс, последовательность, материализованное представление и т. д.) представлен **набором файлов**, которые называются **слоями** (*forks*).
Каждый слой хранит определённый тип информации.

---

## 2. Слои объекта

Для каждого объекта создаются один или несколько слоёв:

| Тип слоя                                                | Назначение                                                                                                                           | Примечания                                                                              |
| ------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------- |
| **Основной слой (main)**                                | Содержит фактические данные — строки таблиц или записи индекса.                                                                      | Есть у всех объектов.                                                                   |
| **Слой инициализации (init)**                           | Используется только для **нежурналируемых** таблиц (`UNLOGGED`). Хранит «пустую копию» данных, которая восстанавливается после сбоя. | У таких таблиц данные не записываются в журнал WAL, поэтому после аварии они очищаются. |
| **Карта видимости (vm, visibility map)**                | Отмечает страницы таблицы, полностью видимые во всех снимках.                                                                        | Используется для ускорения `VACUUM` и индексного доступа.                               |
| **Карта свободного пространства (fsm, free space map)** | Хранит информацию о количестве свободного места в каждой странице.                                                                   | Существует как для таблиц, так и для индексов.                                          |

---

## 3. Структура файлов

Каждый слой хранится в одном или нескольких **файлах-сегментах**.
Один сегмент имеет размер до **1 Гбайта**. Когда файл достигает этого размера, PostgreSQL создаёт следующий — с добавлением номера (например, `16388.1`, `16388.2` и т. д.).

Исторически ограничение в 1 Гбайт связано с несовместимостью старых файловых систем с большими файлами.
Изменить этот размер можно только при сборке сервера из исходных кодов (параметр `--with-segsize`).

### Пример:

Для небольшой таблицы обычно создаются три файла:

* `NNN` — основной слой;
* `NNN_fsm` — карта свободного пространства;
* `NNN_vm` — карта видимости.

Для индекса — два (основной и fsm).

---

## 4. Где хранятся файлы

Файлы объектов, принадлежащих одной базе и одному табличному пространству, хранятся в одном каталоге.
Например:

```
PGDATA/base/16386/
```

где:

* `PGDATA` — корневой каталог кластера;
* `base` — табличное пространство `pg_default`;
* `16386` — идентификатор базы данных;
* файлы с именами `16388`, `16388_fsm`, `16388_vm` и т. д. — отдельные слои объектов.

Такой подход нужно учитывать, поскольку файловые системы не всегда хорошо работают с большим количеством файлов в одном каталоге.

---

## 5. Временные и нежурналируемые таблицы

### Временные таблицы

Хранятся аналогично постоянным, но с префиксом, указывающим схему временных объектов (например, `t4_16397`).
После завершения сеанса или транзакции такие файлы удаляются.

### Нежурналируемые таблицы (`UNLOGGED`)

Не пишут свои изменения в журнал WAL, что ускоряет работу, но делает их **недолговечными**: после сбоя сервер удаляет их содержимое, заменяя основной слой на слой инициализации (`_init`), который хранит пустую структуру таблицы.

---

## 6. Инструмент `oid2name`

Каждый объект в PostgreSQL имеет **уникальный числовой идентификатор (OID)**.
Чтобы связать имена таблиц с файлами, используется стандартная утилита **`oid2name`**.

Она позволяет:

* вывести список баз данных и табличных пространств;
* отобразить соответствие между именами таблиц и их файловыми именами;
* определить таблицу по номеру файла и наоборот.

---

## 7. Размеры слоёв и объектов

Размер каждого слоя можно узнать функцией:

```sql
SELECT
  pg_relation_size('t', 'main') AS main,
  pg_relation_size('t', 'fsm') AS fsm,
  pg_relation_size('t', 'vm') AS vm;
```

Для таблиц:

* `pg_table_size()` — включает таблицу и её TOAST-часть, но без индексов;
* `pg_indexes_size()` — суммирует размеры всех индексов таблицы (кроме TOAST-индекса);
* `pg_total_relation_size()` — возвращает общий размер таблицы со всеми индексами и TOAST.

---

## 8. Механизм TOAST — хранение «длинных» данных

### Почему нужен TOAST

В PostgreSQL каждая версия строки должна **помещаться в одну страницу (8 КБ)**.
Если строка содержит очень длинные значения (например, большой текст или `numeric` с тысячами знаков), сервер использует специальный механизм **TOAST — The Oversized Attributes Storage Technique**.

### Суть работы TOAST

Когда значение не помещается на страницу:

1. PostgreSQL пытается **сжать** данные;
2. Если сжатие недостаточно — выносит значение в отдельную **TOAST-таблицу**;
3. При необходимости — и сжимает, и выносит одновременно.

TOAST-таблица создаётся автоматически для каждой основной таблицы, в которой есть потенциально «длинные» типы данных.
Она располагается в отдельной схеме `pg_toast` (или `pg_toast_temp_N` для временных таблиц) и содержит фрагменты длинных значений.

> При чтении данных PostgreSQL автоматически «собирает» значение из TOAST-таблицы — для приложения этот процесс полностью прозрачен.

---

## 9. Стратегии хранения длинных данных

Для каждого столбца таблицы может быть определена **стратегия хранения**, которая задаёт, как PostgreSQL будет обращаться с «длинными» значениями.

| Стратегия                     | Описание                                                                                       |
| ----------------------------- | ---------------------------------------------------------------------------------------------- |
| **plain**                     | Хранение «как есть», без сжатия и выноса (для фиксированных типов, например `integer`).        |
| **main**                      | Допускает сжатие, но вынос только при нехватке места.                                          |
| **extended** *(по умолчанию)* | Разрешает и сжатие, и отдельное хранение (наиболее универсальный вариант).                     |
| **external**                  | Запрещает сжатие, но допускает вынос в TOAST-таблицу. Подходит, если данные уже сжаты вручную. |

Пример изменения стратегии:

```sql
ALTER TABLE t ALTER COLUMN n SET STORAGE external;
```

Это влияет только на новые версии строк — существующие данные не перезаписываются.

---

## 10. Версионность и эффективность TOAST

Каждая TOAST-таблица имеет собственный индекс и поддерживает **многоверсионность (MVCC)**.
Если обновление не затрагивает длинное значение, новая версия строки будет ссылаться на то же значение в TOAST-таблице — это экономит место.

---

## 11. Сжатие TOAST-данных

PostgreSQL поддерживает два алгоритма сжатия:

* **pglz** — встроенный алгоритм (используется по умолчанию);
* **lz4** — более быстрый, но чуть менее эффективный по степени сжатия (при условии, что PostgreSQL собран с поддержкой `lz4`).

Проверить текущие настройки можно запросами:

```sql
SHOW default_toast_compression;
SELECT setting, enumvals FROM pg_settings WHERE name = 'default_toast_compression';
```

---

## 12. Пример влияния стратегии и сжатия

* Стратегия `EXTERNAL`: данные хранятся отдельно, но не сжимаются — загрузка быстрая, объём большой.
* Стратегия `EXTENDED + pglz`: данные хранятся сжатыми — загрузка медленнее, объём меньше.
* Стратегия `EXTENDED + lz4`: компромисс между скоростью и степенью сжатия.

---

## 13. Служебные файлы базы данных

Помимо файлов таблиц и индексов, в каталоге базы находятся и служебные файлы:

| Файл               | Назначение                                              |
| ------------------ | ------------------------------------------------------- |
| `pg_filenode.map`  | Соответствие между OID таблиц и их физическими файлами. |
| `pg_internal.init` | Кэш системного каталога.                                |
| `PG_VERSION`       | Версия PostgreSQL.                                      |

Поэтому размер каталога базы (`pg_database_size`) немного больше, чем сумма размеров всех её таблиц.

---

## 14. Краткое резюме

* Каждый объект базы данных хранится в виде одного или нескольких файлов — **слоёв**.
* Основной слой содержит данные, остальные — вспомогательные карты (fsm, vm и др.).
* Большие таблицы разбиваются на **файлы-сегменты** размером до 1 ГБ.
* Для длинных значений используется механизм **TOAST**, который сжимает и/или выносит данные в отдельную таблицу.
* Поведение хранения контролируется стратегиями (`plain`, `main`, `extended`, `external`).
* Размеры можно анализировать функциями `pg_table_size`, `pg_indexes_size`, `pg_total_relation_size`.
* TOAST-таблицы поддерживают собственную версионность и сжатие (`pglz`, `lz4`).
* Каталоги баз содержат и служебные файлы, не учитываемые в размерах таблиц.
