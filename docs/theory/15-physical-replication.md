# Физическая репликация в PostgreSQL

## 1. Зачем нужна репликация

**Репликация** — это механизм синхронизации данных между несколькими серверами PostgreSQL.
Основные задачи, для которых она используется:

1. **Отказоустойчивость** — если один сервер выходит из строя, другой содержит актуальные данные и может быстро принять нагрузку.
2. **Высокая доступность** — возможность проводить технические работы без остановки обслуживания.
3. **Масштабирование** — распределение нагрузки по нескольким серверам, особенно для операций чтения.
4. **Общий доступ к данным** — несколько серверов могут работать с одинаковыми данными.

> Проще говоря, репликация позволяет иметь несколько серверов с одинаковыми данными, один из которых является основным, а остальные — его копиями (репликами).

---

## 2. Виды репликации

### 2.1 Физическая репликация

* Синхронизирует **страницы данных** и **версии строк**.
* Передаются **журнальные записи WAL (Write-Ahead Log)**, которые описывают все изменения данных.
* Реплика «проигрывает» эти записи, восстанавливая состояние, как при восстановлении после сбоя.
* Работает **только для всего кластера**.
* Требует **двоичной совместимости** — одинаковой версии PostgreSQL и архитектуры.

### 2.2 Логическая репликация

* Синхронизирует данные на уровне **строк таблиц**.
* Позволяет выборочно реплицировать таблицы, изменять структуру данных и даже передавать их между разными версиями PostgreSQL.
* Используется для сложных сценариев интеграции, миграции и распределённых систем.

---

## 3. Механизм физической репликации

### Как это работает

1. Основной сервер (**мастер**) создаёт записи в WAL при изменении данных.
2. Эти записи передаются на резервный сервер (**реплику**).
3. Реплика применяет полученные записи к своей копии данных.

> Механизм можно представить как «непрерывное восстановление»: реплика постоянно догоняет основную базу, применяя все изменения.

### Потоковая и файловая репликация

| Тип                      | Описание                                                                | Особенности                                                                                                      |
| ------------------------ | ----------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| **Потоковая репликация** | Реплика получает WAL-записи в реальном времени по протоколу репликации. | Минимальное отставание, постоянная синхронизация.                                                                |
| **Файловая репликация**  | Реплика читает файлы WAL из архива.                                     | Отставание больше, т.к. файлы появляются только после их переключения. Обычно используется как запасной вариант. |

---

## 4. Роли серверов

| Роль                  | Назначение                                        |
| --------------------- | ------------------------------------------------- |
| **Мастер (primary)**  | Основной сервер, выполняет все операции записи.   |
| **Реплика (standby)** | Синхронизируется с мастером, доступна для чтения. |

На практике в кластере может быть несколько реплик.
Процесс `walsender` на мастере отправляет журнальные записи,
а на реплике их принимает процесс `walreceiver` и применяет `startup`.

---

## 5. Уровни журнала WAL

Чтобы репликация работала, в журнал должны записываться все необходимые данные.
Это регулируется параметром **`wal_level`**.

| Значение                   | Назначение                                                                                  |
| -------------------------- | ------------------------------------------------------------------------------------------- |
| `minimal`                  | Минимальный объём данных — только для восстановления после сбоя (репликация невозможна).    |
| `replica` *(по умолчанию)* | Записываются все изменения, необходимые для репликации и восстановления из резервной копии. |
| `logical`                  | Позволяет использовать логическую репликацию.                                               |

> С PostgreSQL 10 уровень `replica` стал значением по умолчанию, поскольку физическая репликация и резервное копирование — стандартные задачи для администраторов.

---

## 6. Использование реплики

По умолчанию реплика работает в режиме **горячего резерва (hot standby)**.
В этом режиме к ней можно подключаться и выполнять **только запросы на чтение**.

### Разрешено

* `SELECT`, `COPY TO`, курсоры;
* `SET`, `RESET` (изменение параметров сессии);
* `BEGIN`, `COMMIT`, `ROLLBACK`;
* создание резервных копий (`pg_basebackup`).

### Запрещено

* любые изменения данных (`INSERT`, `UPDATE`, `DELETE`, `TRUNCATE`);
* команды DDL (`CREATE`, `DROP`, `ALTER`);
* `VACUUM`, `ANALYZE`, `REINDEX`;
* блокировки с изменением (`SELECT FOR UPDATE`);
* команды управления доступом (`GRANT`, `REVOKE`);
* использование последовательностей (`nextval()`).

> Реплика не может менять данные, но она остаётся полноценной базой для запросов на чтение — например, аналитических или отчётных.

Если параметр `hot_standby` выключен, реплика становится **тёплым резервом** — подключение к ней невозможно.

---

## 7. Синхронная и асинхронная репликация

### Асинхронная репликация

* Мастер не ждёт подтверждения от реплики.
* Быстрее, но при сбое основного сервера возможна **потеря части данных** (тех, что ещё не переданы).

### Синхронная репликация

* Мастер завершает транзакцию **только после подтверждения**, что запись WAL получена репликой.
* Медленнее, но обеспечивает **максимальную надёжность**: данные не теряются даже при сбое мастера.
* Настраивается параметрами:

  * `synchronous_commit = on`
  * `synchronous_standby_names` — список реплик, с которыми синхронизация обязательна.

> Выбор между асинхронной и синхронной репликацией — это баланс между скоростью и безопасностью данных.

---

## 8. Реплика для аналитики и отчётов

Реплики часто используют для выполнения **долгих аналитических запросов** (отчётов).
Это снижает нагрузку на основной сервер.

Однако при этом возможны **конфликты**:

* основная база очищает старые версии строк, которые ещё нужны запросам на реплике;
* на мастере происходят блокировки, несовместимые с запросом на реплике.

Чтобы избежать ошибок:

* параметр `max_standby_streaming_delay` задаёт время, на которое можно отложить применение конфликтующих записей;
* параметр `hot_standby_feedback` включает обратную связь, чтобы мастер не удалял строки, нужные запросам на реплике.

> Таким образом, при включённой обратной связи мастер «знает», что на реплике выполняются запросы, и не очищает нужные данные.

---

## 9. Несколько реплик

К основному серверу можно подключить **несколько реплик**.
Это позволяет распределить нагрузку по чтению (например, когда система обрабатывает множество небольших запросов).

Однако:

* для балансировки нагрузки требуется **внешний балансировщик** (PostgreSQL сам этого не делает);
* даже при синхронной репликации **данные на разных репликах могут немного отличаться** во времени;
* если приложение обращается к нескольким серверам одновременно, возможны расхождения данных (например, устаревшие данные на одной из реплик).

> Если же клиент всегда читает данные только с одного сервера, согласованность сохраняется.

---

## 10. Каскадная репликация

Когда несколько реплик напрямую подключены к мастеру, это создаёт дополнительную нагрузку и сетевой трафик.
Решение — **каскадная репликация**: одна реплика получает данные от мастера и передаёт их дальше другим репликам.

**Преимущества:**

* снижает нагрузку на основной сервер;
* уменьшает объём передаваемых данных по сети.

**Особенности:**

* задержка изменений увеличивается для удалённых звеньев цепочки;
* синхронная каскадная репликация не поддерживается — мастер синхронизируется только с прямыми репликами.

---

## 11. Отложенная репликация

**Отложенная (delayed) репликация** — реплика, которая применяет изменения не сразу, а через заданный интервал времени.

**Назначение:**

* восстановление данных на определённый момент в прошлом (например, перед ошибочным удалением);
* просмотр состояния базы «в прошлом»;
* альтернатива архивному восстановлению (point-in-time recovery), но быстрее в работе.

> По сути, отложенная репликация играет роль «машины времени» — можно вернуться к недавнему состоянию без сложных процедур восстановления.

---

## 12. Переключение на реплику

Реплику можно использовать не только для чтения, но и как **резервный сервер** в случае необходимости.

### Виды переключения

| Тип                        | Сценарий                            | Особенности                                                               |
| -------------------------- | ----------------------------------- | ------------------------------------------------------------------------- |
| **Плановое переключение**  | Остановка мастера для обслуживания. | Выполняется вручную, без потери данных.                                   |
| **Аварийное переключение** | Отказ основного сервера.            | Может быть выполнено вручную или автоматически при помощи кластерного ПО. |

После переключения реплика становится новым основным сервером.
Важно гарантировать, что приложение работает **только с одним сервером**, иначе возникает ситуация **split-brain** — часть данных записывается в одну копию, часть — в другую, и объединить их потом невозможно.

---

## 13. Основные выводы

* Физическая репликация основана на **передаче и применении журналов WAL**.
* Это **однонаправленный процесс**: данные идут от мастера к реплике.
* Реплика создаёт **точную копию кластера**, включая все базы данных.
* Механизм репликации служит основой для:

  * обеспечения отказоустойчивости,
  * масштабирования,
  * восстановления после сбоев.
