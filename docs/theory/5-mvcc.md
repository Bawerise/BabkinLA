# Изоляция и многоверсионность (MVCC) в PostgreSQL

## 1. Зачем нужна многоверсионность

Когда несколько пользователей (или программ) одновременно обращаются к одной базе данных, неизбежно возникает ситуация, когда одни читают данные, а другие — изменяют их.
Чтобы данные оставались **согласованными** и система не замедлялась из-за постоянных блокировок, PostgreSQL использует механизм **MVCC — Multiversion Concurrency Control**.

### Основная идея

PostgreSQL хранит **несколько версий одной и той же строки**.
Каждая версия «живет» в течение определённого промежутка времени — от момента вставки (`INSERT`) до момента, когда она заменяется новой версией (`UPDATE`) или помечается как удалённая (`DELETE`).

Вместо того чтобы блокировать строку при каждом изменении, система позволяет:

* **читающим транзакциям** видеть старую, зафиксированную версию данных;
* **пишущим транзакциям** работать со своей новой версией, не мешая остальным.

Каждая версия строки содержит два внутренних поля:

* `xmin` — номер транзакции, которая **создала** эту версию;
* `xmax` — номер транзакции, которая **удалила** или заменила её.

Таким образом, PostgreSQL всегда может определить, **какая версия строки видна** конкретной транзакции.

---

## 2. Снимок данных (Snapshot)

### Что такое снимок

Каждая транзакция в PostgreSQL работает не с «текущими» данными, а с **снимком** — согласованной картиной базы данных на определённый момент времени.
Снимок не копирует данные физически — он описывает, **какие версии строк должны быть видны**.

Снимок определяется двумя элементами:

1. **Номером последней зафиксированной транзакции** на момент его создания;
2. **Списком активных транзакций**, которые в этот момент ещё не завершились.

На основе этой информации сервер понимает:

* какие версии строк можно считать зафиксированными;
* какие нужно игнорировать (поскольку они созданы или изменены ещё не завершёнными транзакциями).

Таким образом, транзакция «видит» базу данных **такой, какой она была** на момент начала её работы.
Это гарантирует согласованность данных, даже если другие пользователи продолжают вносить изменения.

---

## 3. Уровни изоляции транзакций

SQL-стандарт определяет четыре уровня изоляции, которые различаются тем, **насколько сильно** транзакции изолированы друг от друга.

| Уровень                             | Описание                                                                                                   | Поведение в PostgreSQL                                                                    |
| ----------------------------------- | ---------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **Read Uncommitted**                | допускает чтение ещё не зафиксированных данных («грязное чтение»); может давать несогласованные результаты | не поддерживается; работает как Read Committed                                            |
| **Read Committed** *(по умолчанию)* | каждая команда SQL видит состояние данных, зафиксированное **к началу её выполнения**                      | данные могут меняться между запросами одной транзакции                                    |
| **Repeatable Read**                 | снимок данных создаётся один раз — при **первом запросе в транзакции**                                     | все запросы в одной транзакции видят одинаковую картину данных                            |
| **Serializable**                    | самая строгая изоляция, транзакции ведут себя как полностью последовательные                               | возможны «откаты сериализации» — некоторые транзакции прерываются и должны быть повторены |

Таким образом:

* **Read Committed** обеспечивает баланс между согласованностью и производительностью — это режим по умолчанию;
* **Repeatable Read** полезен для отчётов и аналитики;
* **Serializable** гарантирует корректность при сложных зависимостях, но может потребовать повторного выполнения некоторых операций.

---

## 4. Очистка старых версий (VACUUM и горизонт очистки)

Многоверсионность позволяет транзакциям работать параллельно, но приводит к накоплению **устаревших (мертвых) версий** строк.
Их нужно периодически удалять.

PostgreSQL делает это автоматически — процессом **очистки (vacuum)**.
Можно запустить очистку и вручную командой `VACUUM`.

### Горизонт очистки (vacuum horizon)

Для каждой базы данных существует специальная отметка — **номер транзакции**, начиная с которого старые версии строк больше не нужны ни одной активной транзакции.
Версии с меньшими номерами можно безопасно удалить.

### Почему важен контроль за очисткой

Если транзакции длятся слишком долго, они «удерживают» горизонт очистки, мешая удалять старые данные.
В результате:

* таблицы и индексы растут в размерах;
* поиск замедляется, так как приходится просматривать лишние версии строк.

Поэтому важно избегать долгих транзакций и регулярно запускать автоматический `autovacuum`.

---

## 5. Блокировки: когда они действительно нужны

MVCC позволяет выполнять большинство операций **без блокировок**.
Однако в некоторых случаях блокировки всё же используются.

### Основные принципы:

* **Чтение не блокирует** другие транзакции.
  Читающая транзакция просто видит нужную версию строки.
* **Изменение строки блокирует** её только для других операций записи, но не для чтения.
* **Две транзакции не могут одновременно изменить одну и ту же строку.**
  Вторая ждёт завершения первой.

### Блокировки таблиц

Иногда блокировка применяется ко всей таблице, например:

* при удалении или изменении структуры таблицы;
* при перестроении индекса;
* при выполнении некоторых DDL-операций (`ALTER TABLE`, `DROP TABLE`).

Эти блокировки снимаются автоматически после завершения транзакции.
Администратор может также установить пользовательские блокировки вручную, но это требуется редко.

---

## 6. Статусы транзакций

Чтобы понимать, какие версии строк видимы, сервер хранит **служебную информацию о статусах транзакций**.
Эта информация занимает всего **два бита на транзакцию** и хранится в специальных файлах (`pg_xact`) внутри каталога данных.

Возможные состояния:

* **Активна** — транзакция выполняется;
* **Зафиксирована (Committed)** — успешно завершена, её изменения видны;
* **Прервана (Aborted)** — откат выполнен, изменения игнорируются.

Информация о статусе хранится не в самих данных, а отдельно.
Благодаря этому при завершении транзакции серверу достаточно лишь изменить значение в журнале статусов — без физического удаления данных.
Это делает фиксацию и откат быстрыми.

---

## 7. Как MVCC обеспечивает изоляцию и производительность

Механизм MVCC — одно из ключевых преимуществ PostgreSQL.
Он позволяет добиться одновременно:

* **производительности** (поскольку операции чтения не блокируют изменения);
* **согласованности** (каждая транзакция работает со своей «картиной мира»);
* **изоляции** (транзакции не мешают друг другу).

### Краткое резюме:

* В таблицах могут существовать **несколько версий** одной строки;
* Транзакции видят **снимок данных**, соответствующий своему моменту начала;
* Разные уровни изоляции управляют временем создания снимка;
* **Мертвые версии** очищаются процессом `VACUUM`;
* **Писатели не блокируют читателей**, а **читатели не блокируют никого**.

---

## 8. Практические выводы для администратора

1. **MVCC — причина, по которой PostgreSQL устойчив к конкуренции транзакций.**
   Даже при большом числе клиентов система остаётся отзывчивой.
2. **Долгие транзакции опасны.**
   Они мешают очистке старых версий и увеличивают размер базы данных.
3. **Автоматический autovacuum обязателен.**
   Он не просто освобождает место, но и предотвращает падение производительности.
4. **Не стоит бояться одновременной работы пользователей.**
   MVCC обеспечивает правильное поведение без ручных блокировок.
5. **Следует понимать уровни изоляции.**
   От них зависит, какие изменения будет видеть каждая транзакция.
